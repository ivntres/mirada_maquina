import org.openkinect.freenect.*; //openkinect
import org.openkinect.processing.*; //openkinect
import processing.video.*; //video cámara
import com.hamoid.*;  //export


// Kinect Library object
Kinect kinect;
// WebCam
Capture video;
Capture video1;
// Record
VideoExport videoExport;
boolean recording = false;
int fecha; //fecha
float a = 0; // Angle for rotation
float[] depthLookUp = new float[2048]; // We'll use a lookup table so that we don't have to repeat the math over and over


void setup() {
  size(1200, 600, P3D); // Rendering in P3D

// Export
  videoExport = new VideoExport(this);
  videoExport.setDebugging(false);
  
  
// Cámaras Web 
  String[] cameras = Capture.list();
  
  if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
    } else {
    println("Available cameras:");
    for (int i = 0; i < cameras.length; i++) {
      println(cameras[i]);
    }

  video = new Capture(this, cameras[1]);
  video1 = new Capture(this, cameras[26]);
  video.start();
  video1.start();
    }
  
  // ========Kinect 3D==================
  
  kinect = new Kinect(this);
  kinect.initDepth();

  // Lookup table for all possible depth values (0 - 2047)
  for (int i = 0; i < depthLookUp.length; i++) {
    depthLookUp[i] = rawDepthToMeters(i);
  }
    
}

void draw() {

  background(0);
 
  //========= WebCam

  if (video.available()) {
    video.read();
  }
  if (video1.available()) {
    video1.read();
  }

video.filter(POSTERIZE, 2);

image(video, 0, 0, 400, 300);
image(video1, 0, 300, 400, 300);
  
  
  
  // =========Kinect 3D

  // Get the raw depth as array of integers
  int[] depth = kinect.getRawDepth();

  // We're just going to calculate and draw every 4th pixel (equivalent of 160x120)
  int skip = 4;

  // Translate and rotate
  translate(1000, 120, 0); //x = posición inicial, más la mitad, y a cálculo
 // rotateY(a);

  for (int x = 0; x < kinect.width; x += skip) {
    for (int y = 0; y < kinect.height; y += skip) {
      int offset = x + y*kinect.width;

      // Convert kinect data to world xyz coordinate
      int rawDepth = depth[offset];
      PVector v = depthToWorld(x, y, rawDepth);

      stroke(255);
      pushMatrix();
      // Scale up by 200
      float factor = 200;
      translate(v.x*factor, v.y*factor, factor-v.z*factor);
      // Draw a point
      point(0, 0);
      popMatrix();
    }
  }

  // Rotate
 // a += 0.00015f;
  
 // Export
    if (recording) {
    videoExport.saveFrame();
  }  
}

// These functions come from: http://graphics.stanford.edu/~mdfisher/Kinect.html
float rawDepthToMeters(int depthValue) {
  if (depthValue < 2047) {
    return (float)(1.0 / ((double)(depthValue) * -0.0030711016 + 3.3309495161));
  }
  return 0.0f;
}

PVector depthToWorld(int x, int y, int depthValue) {

  final double fx_d = 1.0 / 5.9421434211923247e+02;
  final double fy_d = 1.0 / 5.9104053696870778e+02;
  final double cx_d = 3.3930780975300314e+02;
  final double cy_d = 2.4273913761751615e+02;

  PVector result = new PVector();
  double depth =  depthLookUp[depthValue];//rawDepthToMeters(depthValue);
  result.x = (float)((x - cx_d) * depth * fx_d);
  result.y = (float)((y - cy_d) * depth * fy_d);
  result.z = (float)(depth);
  return result;
}

// Export

void keyPressed() {
  if (key == 'q') {
    fecha();
    recording = true;
    videoExport.setMovieFileName("data/"+ fecha + ".mp4");
    videoExport.startMovie();
    println("Start movie.");
  } else if (key == 'w') {
    recording = false;
    videoExport.endMovie();

  }
}

void fecha() {
  background(204);
  int d = day();    // Values from 1 - 31
  int m = month();  // Values from 1 - 12
  int y = year(); 
  int s = second();  // Values from 0 - 59
  int min = minute();  // Values from 0 - 59
  int h = hour();    // Values from 0 - 23
  fecha = y + m+d+h+min+s;
  //println(fecha);
}
