import org.openkinect.freenect.*; //openkinect
import org.openkinect.processing.*; //openkinect
import processing.video.*; //video cámara
import com.hamoid.*;  //export

// Objetos
PWindow win; //Objeto de ventana
Kinect kinect; //Kinect
Capture video; //WebCam1
Capture video1; //WebCam2
VideoExport videoExport; //Record
// Declaración de variables
boolean recording = false;
int parar = 0;
String fecha; //fecha
float a = 0; // Angle for rotation
float[] depthLookUp = new float[2048]; // We'll use a lookup table so that we don't have to repeat the math over and over
PFont f; //fuente de texto
int posTextY; //Posición de texto en Y
int posTextX; //Posición de texto en X
int velocidad; //Velocidad de texto
int posRot;

void setup() {
  
  win = new PWindow();
  // Texto
  f = createFont("Arial Narrow", 20);   // Create the font
  textFont(f);
  posTextY = 800;  //Posición texto respecto a y
  posTextX = 420;
  String[] lines = loadStrings("text.txt");


  // Video Export
  videoExport = new VideoExport(this);
  videoExport.setDebugging(false);
  
  
// Cámaras Web 
  String[] cameras = Capture.list();
  
  if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
    } else {
    println("Available cameras:");
    for (int i = 0; i < cameras.length; i++) {
      println(i+"--"+cameras[i]);
    }

  video = new Capture(this, cameras[1]);
  video1 = new Capture(this, cameras[26]);
  video.start();
  video1.start();
    }
  
  // ========Kinect 3D==================
  
  kinect = new Kinect(this);
  kinect.initDepth();

  // Lookup table for all possible depth values (0 - 2047)
  for (int i = 0; i < depthLookUp.length; i++) {
    depthLookUp[i] = rawDepthToMeters(i);
  }
    
} //Fin setup

void draw() {
  background(0);
  texto();
 
  
  //========= WebCam
  if (video.available()) {
    video.read();
  }
  if (video1.available()) {
    video1.read();
  }

  // Configuración de los filtros de video
  video.filter(THRESHOLD);
  video1.filter(GRAY);
  // Posición y configuración del video como imagen
  image(video, 0, 0, 400, 300);
  image(video1, 0, 300, 400, 300);
  
  kinect3D(); //Llamada a función de kinect
  
  // Video Export
    if (recording) {
      videoExport.saveFrame();
    }  
} // Fin de Draw

// These functions come from: http://graphics.stanford.edu/~mdfisher/Kinect.html
float rawDepthToMeters(int depthValue) {
  if (depthValue < 2047) {
    return (float)(1.0 / ((double)(depthValue) * -0.0030711016 + 3.3309495161));
  }
  return 0.0f;
}

PVector depthToWorld(int x, int y, int depthValue) {

  final double fx_d = 1.0 / 5.9421434211923247e+02;
  final double fy_d = 1.0 / 5.9104053696870778e+02;
  final double cx_d = 3.3930780975300314e+02;
  final double cy_d = 2.4273913761751615e+02;

  PVector result = new PVector();
  double depth =  depthLookUp[depthValue];//rawDepthToMeters(depthValue);
  result.x = (float)((x - cx_d) * depth * fx_d);
  result.y = (float)((y - cy_d) * depth * fy_d);
  result.z = (float)(depth);
  return result;
}  

class PWindow extends PApplet {
  PWindow() {
    super();
    PApplet.runSketch(new String[] {this.getClass().getSimpleName()}, this);
  }

  void settings() {
    size(150, 800);
  }

  void setup() {
    background(0);
  }

  void draw() {
    ellipse(random(width), random(height), random(50), random(50));
  }

  void mousePressed() {
    println("mousePressed in thirty window");
  }
}

public void settings(){
  size(1200, 600, P3D); // Rendering in P3D
}

void keyPressed() {
  if (key == 'q') {
    fecha();
    recording = true;
    videoExport.setMovieFileName("data/"+ fecha + ".mp4");
    videoExport.startMovie();
    println("Start movie.");
  } else if (key == 'w') {
    recording = false;
    videoExport.endMovie();

  } else if (key == ESC){
    parar = 0;
  }
}

void fecha() {
  background(204);
  int d = day();    // Values from 1 - 31
  int m = month();  // Values from 1 - 12
  int y = year(); 
  int s = second();  // Values from 0 - 59
  int min = minute();  // Values from 0 - 59
  int h = hour();    // Values from 0 - 23
  String ds = str(d);
  String ms = str(m);
  String ys = str(y);
  String ss = str(s);
  String mins = str(min);
  String hs = str(h);
  fecha = ys+ms+ds+hs+mins+ss;
  //println(fecha);
}

void kinect3D(){
  // =========Kinect 3D

  // Get the raw depth as array of integers
  int[] depth = kinect.getRawDepth();

  // We're just going to calculate and draw every 4th pixel (equivalent of 160x120)
  int skip = 4;

  // Translate and rotate
  translate(800, 150, 0); //x = posición inicial, más la mitad, y a cálculo
 // rotateY(a);

  for (int x = 0; x < kinect.width; x += skip) {
    for (int y = 0; y < kinect.height; y += skip) {
      int offset = x + y*kinect.width;

      // Convert kinect data to world xyz coordinate
      int rawDepth = depth[offset];
      PVector v = depthToWorld(x, y, rawDepth);

      stroke(255);
      pushMatrix();
      // Scale up by 200
      float factor = 200;
      translate(v.x*factor, v.y*factor, factor-v.z*factor);
      // Draw a point
      point(0, 0);
      popMatrix();
    }
  }

  // Rotate
  // a += 0.00015f;
 
}




void texto() {
  velocidad = velocidad-1;
  manifesto(velocidad);
}


void manifesto(int posY){
  String[] lines = loadStrings("text/text1.txt");
 // println("there are " + lines.length + " lines");
  for (int ia = 0 ; ia < lines.length; ia++) {
    posRot= posY+(40+ia*20);
    // text(lines[ia], posTextX, posRot);
     if (posRot<400){
     //text(".", posTextX, posRot);
     } else {
     text(lines[ia], posTextX, posRot);
     }
    if (ia == lines.length){
      ia=0;
      posRot = posY+(40+ia*20);
    }     

   }

}


import org.openkinect.freenect.*; //openkinect
import org.openkinect.processing.*; //openkinect
import processing.video.*; //video cámara
import com.hamoid.*;  //export

// Objetos
PWindow win; //Objeto de ventana
Kinect kinect; //Kinect
Capture video; //WebCam1
Capture video1; //WebCam2
VideoExport videoExport; //Record
// Declaración de variables
boolean recording = false;
int parar = 0;
String fecha; //fecha
float a = 0; // Angle for rotation
float[] depthLookUp = new float[2048]; // We'll use a lookup table so that we don't have to repeat the math over and over
PFont f; //fuente de texto
int posTextY; //Posición de texto en Y
int posTextX; //Posición de texto en X
int velocidad; //Velocidad de texto
int posRot;

void setup() {
  
  win = new PWindow();
  // Texto
  f = createFont("Arial Narrow", 20);   // Create the font
  textFont(f);
  posTextY = 800;  //Posición texto respecto a y
  posTextX = 420;
  String[] lines = loadStrings("text.txt");


  // Video Export
  videoExport = new VideoExport(this);
  videoExport.setDebugging(false);
  
  
// Cámaras Web 
  String[] cameras = Capture.list();
  
  if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
    } else {
    println("Available cameras:");
    for (int i = 0; i < cameras.length; i++) {
      println(i+"--"+cameras[i]);
    }

  video = new Capture(this, cameras[1]);
  video1 = new Capture(this, cameras[26]);
  video.start();
  video1.start();
    }
  
  // ========Kinect 3D==================
  
  kinect = new Kinect(this);
  kinect.initDepth();

  // Lookup table for all possible depth values (0 - 2047)
  for (int i = 0; i < depthLookUp.length; i++) {
    depthLookUp[i] = rawDepthToMeters(i);
  }
    
} //Fin setup

void draw() {
  background(0);
  texto();
 
  
  //========= WebCam
  if (video.available()) {
    video.read();
  }
  if (video1.available()) {
    video1.read();
  }

  // Configuración de los filtros de video
  video.filter(THRESHOLD);
  video1.filter(GRAY);
  // Posición y configuración del video como imagen
  image(video, 0, 0, 400, 300);
  image(video1, 0, 300, 400, 300);
  
  kinect3D(); //Llamada a función de kinect
  
  // Video Export
    if (recording) {
      videoExport.saveFrame();
    }  
} // Fin de Draw

// These functions come from: http://graphics.stanford.edu/~mdfisher/Kinect.html
float rawDepthToMeters(int depthValue) {
  if (depthValue < 2047) {
    return (float)(1.0 / ((double)(depthValue) * -0.0030711016 + 3.3309495161));
  }
  return 0.0f;
}

PVector depthToWorld(int x, int y, int depthValue) {

  final double fx_d = 1.0 / 5.9421434211923247e+02;
  final double fy_d = 1.0 / 5.9104053696870778e+02;
  final double cx_d = 3.3930780975300314e+02;
  final double cy_d = 2.4273913761751615e+02;

  PVector result = new PVector();
  double depth =  depthLookUp[depthValue];//rawDepthToMeters(depthValue);
  result.x = (float)((x - cx_d) * depth * fx_d);
  result.y = (float)((y - cy_d) * depth * fy_d);
  result.z = (float)(depth);
  return result;
}  

class PWindow extends PApplet {
  PWindow() {
    super();
    PApplet.runSketch(new String[] {this.getClass().getSimpleName()}, this);
  }

  void settings() {
    size(150, 800);
  }

  void setup() {
    background(0);
  }

  void draw() {
    ellipse(random(width), random(height), random(50), random(50));
  }

  void mousePressed() {
    println("mousePressed in thirty window");
  }
}

public void settings(){
  size(1200, 600, P3D); // Rendering in P3D
}

void keyPressed() {
  if (key == 'q') {
    fecha();
    recording = true;
    videoExport.setMovieFileName("data/"+ fecha + ".mp4");
    videoExport.startMovie();
    println("Start movie.");
  } else if (key == 'w') {
    recording = false;
    videoExport.endMovie();

  } else if (key == ESC){
    parar = 0;
  }
}

void fecha() {
  background(204);
  int d = day();    // Values from 1 - 31
  int m = month();  // Values from 1 - 12
  int y = year(); 
  int s = second();  // Values from 0 - 59
  int min = minute();  // Values from 0 - 59
  int h = hour();    // Values from 0 - 23
  String ds = str(d);
  String ms = str(m);
  String ys = str(y);
  String ss = str(s);
  String mins = str(min);
  String hs = str(h);
  fecha = ys+ms+ds+hs+mins+ss;
  //println(fecha);
}

void kinect3D(){
  // =========Kinect 3D

  // Get the raw depth as array of integers
  int[] depth = kinect.getRawDepth();

  // We're just going to calculate and draw every 4th pixel (equivalent of 160x120)
  int skip = 4;

  // Translate and rotate
  translate(800, 150, 0); //x = posición inicial, más la mitad, y a cálculo
 // rotateY(a);

  for (int x = 0; x < kinect.width; x += skip) {
    for (int y = 0; y < kinect.height; y += skip) {
      int offset = x + y*kinect.width;

      // Convert kinect data to world xyz coordinate
      int rawDepth = depth[offset];
      PVector v = depthToWorld(x, y, rawDepth);

      stroke(255);
      pushMatrix();
      // Scale up by 200
      float factor = 200;
      translate(v.x*factor, v.y*factor, factor-v.z*factor);
      // Draw a point
      point(0, 0);
      popMatrix();
    }
  }

  // Rotate
  // a += 0.00015f;
 
}




void texto() {
  velocidad = velocidad-1;
  manifesto(velocidad);
}


void manifesto(int posY){
  String[] lines = loadStrings("text/text1.txt");
 // println("there are " + lines.length + " lines");
  for (int ia = 0 ; ia < lines.length; ia++) {
    posRot= posY+(40+ia*20);
    // text(lines[ia], posTextX, posRot);
     if (posRot<400){
     //text(".", posTextX, posRot);
     } else {
     text(lines[ia], posTextX, posRot);
     }
    if (ia == lines.length){
      ia=0;
      posRot = posY+(40+ia*20);
    }     

   }

}


import org.openkinect.freenect.*; //openkinect
import org.openkinect.processing.*; //openkinect
import processing.video.*; //video cámara
import com.hamoid.*;  //export

// Objetos
PWindow win; //Objeto de ventana
Kinect kinect; //Kinect
Capture video; //WebCam1
Capture video1; //WebCam2
VideoExport videoExport; //Record
// Declaración de variables
boolean recording = false;
int parar = 0;
String fecha; //fecha
float a = 0; // Angle for rotation
float[] depthLookUp = new float[2048]; // We'll use a lookup table so that we don't have to repeat the math over and over
PFont f; //fuente de texto
int posTextY; //Posición de texto en Y
int posTextX; //Posición de texto en X
int velocidad; //Velocidad de texto
int posRot;

void setup() {
  
  win = new PWindow();
  // Texto
  f = createFont("Arial Narrow", 20);   // Create the font
  textFont(f);
  posTextY = 800;  //Posición texto respecto a y
  posTextX = 420;
  String[] lines = loadStrings("text.txt");


  // Video Export
  videoExport = new VideoExport(this);
  videoExport.setDebugging(false);
  
  
// Cámaras Web 
  String[] cameras = Capture.list();
  
  if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
    } else {
    println("Available cameras:");
    for (int i = 0; i < cameras.length; i++) {
      println(i+"--"+cameras[i]);
    }

  video = new Capture(this, cameras[1]);
  video1 = new Capture(this, cameras[26]);
  video.start();
  video1.start();
    }
  
  // ========Kinect 3D==================
  
  kinect = new Kinect(this);
  kinect.initDepth();

  // Lookup table for all possible depth values (0 - 2047)
  for (int i = 0; i < depthLookUp.length; i++) {
    depthLookUp[i] = rawDepthToMeters(i);
  }
    
} //Fin setup

void draw() {
  background(0);
  texto();
 
  
  //========= WebCam
  if (video.available()) {
    video.read();
  }
  if (video1.available()) {
    video1.read();
  }

  // Configuración de los filtros de video
  video.filter(THRESHOLD);
  video1.filter(GRAY);
  // Posición y configuración del video como imagen
  image(video, 0, 0, 400, 300);
  image(video1, 0, 300, 400, 300);
  
  kinect3D(); //Llamada a función de kinect
  
  // Video Export
    if (recording) {
      videoExport.saveFrame();
    }  
} // Fin de Draw

// These functions come from: http://graphics.stanford.edu/~mdfisher/Kinect.html
float rawDepthToMeters(int depthValue) {
  if (depthValue < 2047) {
    return (float)(1.0 / ((double)(depthValue) * -0.0030711016 + 3.3309495161));
  }
  return 0.0f;
}

PVector depthToWorld(int x, int y, int depthValue) {

  final double fx_d = 1.0 / 5.9421434211923247e+02;
  final double fy_d = 1.0 / 5.9104053696870778e+02;
  final double cx_d = 3.3930780975300314e+02;
  final double cy_d = 2.4273913761751615e+02;

  PVector result = new PVector();
  double depth =  depthLookUp[depthValue];//rawDepthToMeters(depthValue);
  result.x = (float)((x - cx_d) * depth * fx_d);
  result.y = (float)((y - cy_d) * depth * fy_d);
  result.z = (float)(depth);
  return result;
}  

class PWindow extends PApplet {
  PWindow() {
    super();
    PApplet.runSketch(new String[] {this.getClass().getSimpleName()}, this);
  }

  void settings() {
    size(150, 800);
  }

  void setup() {
    background(0);
  }

  void draw() {
    ellipse(random(width), random(height), random(50), random(50));
  }

  void mousePressed() {
    println("mousePressed in thirty window");
  }
}

public void settings(){
  size(1200, 600, P3D); // Rendering in P3D
}

void keyPressed() {
  if (key == 'q') {
    fecha();
    recording = true;
    videoExport.setMovieFileName("data/"+ fecha + ".mp4");
    videoExport.startMovie();
    println("Start movie.");
  } else if (key == 'w') {
    recording = false;
    videoExport.endMovie();

  } else if (key == ESC){
    parar = 0;
  }
}

void fecha() {
  background(204);
  int d = day();    // Values from 1 - 31
  int m = month();  // Values from 1 - 12
  int y = year(); 
  int s = second();  // Values from 0 - 59
  int min = minute();  // Values from 0 - 59
  int h = hour();    // Values from 0 - 23
  String ds = str(d);
  String ms = str(m);
  String ys = str(y);
  String ss = str(s);
  String mins = str(min);
  String hs = str(h);
  fecha = ys+ms+ds+hs+mins+ss;
  //println(fecha);
}

void kinect3D(){
  // =========Kinect 3D

  // Get the raw depth as array of integers
  int[] depth = kinect.getRawDepth();

  // We're just going to calculate and draw every 4th pixel (equivalent of 160x120)
  int skip = 4;

  // Translate and rotate
  translate(800, 150, 0); //x = posición inicial, más la mitad, y a cálculo
 // rotateY(a);

  for (int x = 0; x < kinect.width; x += skip) {
    for (int y = 0; y < kinect.height; y += skip) {
      int offset = x + y*kinect.width;

      // Convert kinect data to world xyz coordinate
      int rawDepth = depth[offset];
      PVector v = depthToWorld(x, y, rawDepth);

      stroke(255);
      pushMatrix();
      // Scale up by 200
      float factor = 200;
      translate(v.x*factor, v.y*factor, factor-v.z*factor);
      // Draw a point
      point(0, 0);
      popMatrix();
    }
  }

  // Rotate
  // a += 0.00015f;
 
}




void texto() {
  velocidad = velocidad-1;
  manifesto(velocidad);
}


void manifesto(int posY){
  String[] lines = loadStrings("text/text1.txt");
 // println("there are " + lines.length + " lines");
  for (int ia = 0 ; ia < lines.length; ia++) {
    posRot= posY+(40+ia*20);
    // text(lines[ia], posTextX, posRot);
     if (posRot<400){
     //text(".", posTextX, posRot);
     } else {
     text(lines[ia], posTextX, posRot);
     }
    if (ia == lines.length){
      ia=0;
      posRot = posY+(40+ia*20);
    }     

   }

}

import org.openkinect.freenect.*; //openkinect
import org.openkinect.processing.*; //openkinect
import processing.video.*; //video cámara
import com.hamoid.*;  //export

// Objetos
PWindow win; //Objeto de ventana
Kinect kinect; //Kinect
Capture video; //WebCam1
Capture video1; //WebCam2
VideoExport videoExport; //Record
// Declaración de variables
boolean recording = false;
int parar = 0;
String fecha; //fecha
float a = 0; // Angle for rotation
float[] depthLookUp = new float[2048]; // We'll use a lookup table so that we don't have to repeat the math over and over
PFont f; //fuente de texto
int posTextY; //Posición de texto en Y
int posTextX; //Posición de texto en X
int velocidad; //Velocidad de texto
int posRot;

void setup() {
  
  win = new PWindow();
  // Texto
  f = createFont("Arial Narrow", 20);   // Create the font
  textFont(f);
  posTextY = 800;  //Posición texto respecto a y
  posTextX = 420;
  String[] lines = loadStrings("text.txt");


  // Video Export
  videoExport = new VideoExport(this);
  videoExport.setDebugging(false);
  
  
// Cámaras Web 
  String[] cameras = Capture.list();
  
  if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
    } else {
    println("Available cameras:");
    for (int i = 0; i < cameras.length; i++) {
      println(i+"--"+cameras[i]);
    }

  video = new Capture(this, cameras[1]);
  video1 = new Capture(this, cameras[26]);
  video.start();
  video1.start();
    }
  
  // ========Kinect 3D==================
  
  kinect = new Kinect(this);
  kinect.initDepth();

  // Lookup table for all possible depth values (0 - 2047)
  for (int i = 0; i < depthLookUp.length; i++) {
    depthLookUp[i] = rawDepthToMeters(i);
  }
    
} //Fin setup

void draw() {
  background(0);
  texto();
 
  
  //========= WebCam
  if (video.available()) {
    video.read();
  }
  if (video1.available()) {
    video1.read();
  }

  // Configuración de los filtros de video
  video.filter(THRESHOLD);
  video1.filter(GRAY);
  // Posición y configuración del video como imagen
  image(video, 0, 0, 400, 300);
  image(video1, 0, 300, 400, 300);
  
  kinect3D(); //Llamada a función de kinect
  
  // Video Export
    if (recording) {
      videoExport.saveFrame();
    }  
} // Fin de Draw

// These functions come from: http://graphics.stanford.edu/~mdfisher/Kinect.html
float rawDepthToMeters(int depthValue) {
  if (depthValue < 2047) {
    return (float)(1.0 / ((double)(depthValue) * -0.0030711016 + 3.3309495161));
  }
  return 0.0f;
}

PVector depthToWorld(int x, int y, int depthValue) {

  final double fx_d = 1.0 / 5.9421434211923247e+02;
  final double fy_d = 1.0 / 5.9104053696870778e+02;
  final double cx_d = 3.3930780975300314e+02;
  final double cy_d = 2.4273913761751615e+02;

  PVector result = new PVector();
  double depth =  depthLookUp[depthValue];//rawDepthToMeters(depthValue);
  result.x = (float)((x - cx_d) * depth * fx_d);
  result.y = (float)((y - cy_d) * depth * fy_d);
  result.z = (float)(depth);
  return result;
}  

class PWindow extends PApplet {
  PWindow() {
    super();
    PApplet.runSketch(new String[] {this.getClass().getSimpleName()}, this);
  }

  void settings() {
    size(150, 800);
  }

  void setup() {
    background(0);
  }

  void draw() {
    ellipse(random(width), random(height), random(50), random(50));
  }

  void mousePressed() {
    println("mousePressed in thirty window");
  }
}

public void settings(){
  size(1200, 600, P3D); // Rendering in P3D
}

void keyPressed() {
  if (key == 'q') {
    fecha();
    recording = true;
    videoExport.setMovieFileName("data/"+ fecha + ".mp4");
    videoExport.startMovie();
    println("Start movie.");
  } else if (key == 'w') {
    recording = false;
    videoExport.endMovie();

  } else if (key == ESC){
    parar = 0;
  }
}

void fecha() {
  background(204);
  int d = day();    // Values from 1 - 31
  int m = month();  // Values from 1 - 12
  int y = year(); 
  int s = second();  // Values from 0 - 59
  int min = minute();  // Values from 0 - 59
  int h = hour();    // Values from 0 - 23
  String ds = str(d);
  String ms = str(m);
  String ys = str(y);
  String ss = str(s);
  String mins = str(min);
  String hs = str(h);
  fecha = ys+ms+ds+hs+mins+ss;
  //println(fecha);
}

void kinect3D(){
  // =========Kinect 3D

  // Get the raw depth as array of integers
  int[] depth = kinect.getRawDepth();

  // We're just going to calculate and draw every 4th pixel (equivalent of 160x120)
  int skip = 4;

  // Translate and rotate
  translate(800, 150, 0); //x = posición inicial, más la mitad, y a cálculo
 // rotateY(a);

  for (int x = 0; x < kinect.width; x += skip) {
    for (int y = 0; y < kinect.height; y += skip) {
      int offset = x + y*kinect.width;

      // Convert kinect data to world xyz coordinate
      int rawDepth = depth[offset];
      PVector v = depthToWorld(x, y, rawDepth);

      stroke(255);
      pushMatrix();
      // Scale up by 200
      float factor = 200;
      translate(v.x*factor, v.y*factor, factor-v.z*factor);
      // Draw a point
      point(0, 0);
      popMatrix();
    }
  }

  // Rotate
  // a += 0.00015f;
 
}




void texto() {
  velocidad = velocidad-1;
  manifesto(velocidad);
}


void manifesto(int posY){
  String[] lines = loadStrings("text/text1.txt");
 // println("there are " + lines.length + " lines");
  for (int ia = 0 ; ia < lines.length; ia++) {
    posRot= posY+(40+ia*20);
    // text(lines[ia], posTextX, posRot);
     if (posRot<400){
     //text(".", posTextX, posRot);
     } else {
     text(lines[ia], posTextX, posRot);
     }
    if (ia == lines.length){
      ia=0;
      posRot = posY+(40+ia*20);
    }     

   }

}

import org.openkinect.freenect.*; //openkinect
import org.openkinect.processing.*; //openkinect
import processing.video.*; //video cámara
import com.hamoid.*;  //export

// Objetos
PWindow win; //Objeto de ventana
Kinect kinect; //Kinect
Capture video; //WebCam1
Capture video1; //WebCam2
VideoExport videoExport; //Record
// Declaración de variables
boolean recording = false;
int parar = 0;
String fecha; //fecha
float a = 0; // Angle for rotation
float[] depthLookUp = new float[2048]; // We'll use a lookup table so that we don't have to repeat the math over and over
PFont f; //fuente de texto
int posTextY; //Posición de texto en Y
int posTextX; //Posición de texto en X
int velocidad; //Velocidad de texto
int posRot;

void setup() {
  
  win = new PWindow();
  // Texto
  f = createFont("Arial Narrow", 20);   // Create the font
  textFont(f);
  posTextY = 800;  //Posición texto respecto a y
  posTextX = 420;
  String[] lines = loadStrings("text.txt");


  // Video Export
  videoExport = new VideoExport(this);
  videoExport.setDebugging(false);
  
  
// Cámaras Web 
  String[] cameras = Capture.list();
  
  if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
    } else {
    println("Available cameras:");
    for (int i = 0; i < cameras.length; i++) {
      println(i+"--"+cameras[i]);
    }

  video = new Capture(this, cameras[1]);
  video1 = new Capture(this, cameras[26]);
  video.start();
  video1.start();
    }
  
  // ========Kinect 3D==================
  
  kinect = new Kinect(this);
  kinect.initDepth();

  // Lookup table for all possible depth values (0 - 2047)
  for (int i = 0; i < depthLookUp.length; i++) {
    depthLookUp[i] = rawDepthToMeters(i);
  }
    
} //Fin setup

void draw() {
  background(0);
  texto();
 
  
  //========= WebCam
  if (video.available()) {
    video.read();
  }
  if (video1.available()) {
    video1.read();
  }

  // Configuración de los filtros de video
  video.filter(THRESHOLD);
  video1.filter(GRAY);
  // Posición y configuración del video como imagen
  image(video, 0, 0, 400, 300);
  image(video1, 0, 300, 400, 300);
  
  kinect3D(); //Llamada a función de kinect
  
  // Video Export
    if (recording) {
      videoExport.saveFrame();
    }  
} // Fin de Draw

// These functions come from: http://graphics.stanford.edu/~mdfisher/Kinect.html
float rawDepthToMeters(int depthValue) {
  if (depthValue < 2047) {
    return (float)(1.0 / ((double)(depthValue) * -0.0030711016 + 3.3309495161));
  }
  return 0.0f;
}

PVector depthToWorld(int x, int y, int depthValue) {

  final double fx_d = 1.0 / 5.9421434211923247e+02;
  final double fy_d = 1.0 / 5.9104053696870778e+02;
  final double cx_d = 3.3930780975300314e+02;
  final double cy_d = 2.4273913761751615e+02;

  PVector result = new PVector();
  double depth =  depthLookUp[depthValue];//rawDepthToMeters(depthValue);
  result.x = (float)((x - cx_d) * depth * fx_d);
  result.y = (float)((y - cy_d) * depth * fy_d);
  result.z = (float)(depth);
  return result;
}  

class PWindow extends PApplet {
  PWindow() {
    super();
    PApplet.runSketch(new String[] {this.getClass().getSimpleName()}, this);
  }

  void settings() {
    size(150, 800);
  }

  void setup() {
    background(0);
  }

  void draw() {
    ellipse(random(width), random(height), random(50), random(50));
  }

  void mousePressed() {
    println("mousePressed in thirty window");
  }
}

public void settings(){
  size(1200, 600, P3D); // Rendering in P3D
}

void keyPressed() {
  if (key == 'q') {
    fecha();
    recording = true;
    videoExport.setMovieFileName("data/"+ fecha + ".mp4");
    videoExport.startMovie();
    println("Start movie.");
  } else if (key == 'w') {
    recording = false;
    videoExport.endMovie();

  } else if (key == ESC){
    parar = 0;
  }
}

void fecha() {
  background(204);
  int d = day();    // Values from 1 - 31
  int m = month();  // Values from 1 - 12
  int y = year(); 
  int s = second();  // Values from 0 - 59
  int min = minute();  // Values from 0 - 59
  int h = hour();    // Values from 0 - 23
  String ds = str(d);
  String ms = str(m);
  String ys = str(y);
  String ss = str(s);
  String mins = str(min);
  String hs = str(h);
  fecha = ys+ms+ds+hs+mins+ss;
  //println(fecha);
}

void kinect3D(){
  // =========Kinect 3D

  // Get the raw depth as array of integers
  int[] depth = kinect.getRawDepth();

  // We're just going to calculate and draw every 4th pixel (equivalent of 160x120)
  int skip = 4;

  // Translate and rotate
  translate(800, 150, 0); //x = posición inicial, más la mitad, y a cálculo
 // rotateY(a);

  for (int x = 0; x < kinect.width; x += skip) {
    for (int y = 0; y < kinect.height; y += skip) {
      int offset = x + y*kinect.width;

      // Convert kinect data to world xyz coordinate
      int rawDepth = depth[offset];
      PVector v = depthToWorld(x, y, rawDepth);

      stroke(255);
      pushMatrix();
      // Scale up by 200
      float factor = 200;
      translate(v.x*factor, v.y*factor, factor-v.z*factor);
      // Draw a point
      point(0, 0);
      popMatrix();
    }
  }

  // Rotate
  // a += 0.00015f;
 
}




void texto() {
  velocidad = velocidad-1;
  manifesto(velocidad);
}


void manifesto(int posY){
  String[] lines = loadStrings("text/text1.txt");
 // println("there are " + lines.length + " lines");
  for (int ia = 0 ; ia < lines.length; ia++) {
    posRot= posY+(40+ia*20);
    // text(lines[ia], posTextX, posRot);
     if (posRot<400){
     //text(".", posTextX, posRot);
     } else {
     text(lines[ia], posTextX, posRot);
     }
    if (ia == lines.length){
      ia=0;
      posRot = posY+(40+ia*20);
    }     

   }

}

import org.openkinect.freenect.*; //openkinect
import org.openkinect.processing.*; //openkinect
import processing.video.*; //video cámara
import com.hamoid.*;  //export

// Objetos
PWindow win; //Objeto de ventana
Kinect kinect; //Kinect
Capture video; //WebCam1
Capture video1; //WebCam2
VideoExport videoExport; //Record
// Declaración de variables
boolean recording = false;
int parar = 0;
String fecha; //fecha
float a = 0; // Angle for rotation
float[] depthLookUp = new float[2048]; // We'll use a lookup table so that we don't have to repeat the math over and over
PFont f; //fuente de texto
int posTextY; //Posición de texto en Y
int posTextX; //Posición de texto en X
int velocidad; //Velocidad de texto
int posRot;

void setup() {
  
  win = new PWindow();
  // Texto
  f = createFont("Arial Narrow", 20);   // Create the font
  textFont(f);
  posTextY = 800;  //Posición texto respecto a y
  posTextX = 420;
  String[] lines = loadStrings("text.txt");


  // Video Export
  videoExport = new VideoExport(this);
  videoExport.setDebugging(false);
  
  
// Cámaras Web 
  String[] cameras = Capture.list();
  
  if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
    } else {
    println("Available cameras:");
    for (int i = 0; i < cameras.length; i++) {
      println(i+"--"+cameras[i]);
    }

  video = new Capture(this, cameras[1]);
  video1 = new Capture(this, cameras[26]);
  video.start();
  video1.start();
    }
  
  // ========Kinect 3D==================
  
  kinect = new Kinect(this);
  kinect.initDepth();

  // Lookup table for all possible depth values (0 - 2047)
  for (int i = 0; i < depthLookUp.length; i++) {
    depthLookUp[i] = rawDepthToMeters(i);
  }
    
} //Fin setup

void draw() {
  background(0);
  texto();
 
  
  //========= WebCam
  if (video.available()) {
    video.read();
  }
  if (video1.available()) {
    video1.read();
  }

  // Configuración de los filtros de video
  video.filter(THRESHOLD);
  video1.filter(GRAY);
  // Posición y configuración del video como imagen
  image(video, 0, 0, 400, 300);
  image(video1, 0, 300, 400, 300);
  
  kinect3D(); //Llamada a función de kinect
  
  // Video Export
    if (recording) {
      videoExport.saveFrame();
    }  
} // Fin de Draw

// These functions come from: http://graphics.stanford.edu/~mdfisher/Kinect.html
float rawDepthToMeters(int depthValue) {
  if (depthValue < 2047) {
    return (float)(1.0 / ((double)(depthValue) * -0.0030711016 + 3.3309495161));
  }
  return 0.0f;
}

PVector depthToWorld(int x, int y, int depthValue) {

  final double fx_d = 1.0 / 5.9421434211923247e+02;
  final double fy_d = 1.0 / 5.9104053696870778e+02;
  final double cx_d = 3.3930780975300314e+02;
  final double cy_d = 2.4273913761751615e+02;

  PVector result = new PVector();
  double depth =  depthLookUp[depthValue];//rawDepthToMeters(depthValue);
  result.x = (float)((x - cx_d) * depth * fx_d);
  result.y = (float)((y - cy_d) * depth * fy_d);
  result.z = (float)(depth);
  return result;
}  

class PWindow extends PApplet {
  PWindow() {
    super();
    PApplet.runSketch(new String[] {this.getClass().getSimpleName()}, this);
  }

  void settings() {
    size(150, 800);
  }

  void setup() {
    background(0);
  }

  void draw() {
    ellipse(random(width), random(height), random(50), random(50));
  }

  void mousePressed() {
    println("mousePressed in thirty window");
  }
}

public void settings(){
  size(1200, 600, P3D); // Rendering in P3D
}

void keyPressed() {
  if (key == 'q') {
    fecha();
    recording = true;
    videoExport.setMovieFileName("data/"+ fecha + ".mp4");
    videoExport.startMovie();
    println("Start movie.");
  } else if (key == 'w') {
    recording = false;
    videoExport.endMovie();

  } else if (key == ESC){
    parar = 0;
  }
}

void fecha() {
  background(204);
  int d = day();    // Values from 1 - 31
  int m = month();  // Values from 1 - 12
  int y = year(); 
  int s = second();  // Values from 0 - 59
  int min = minute();  // Values from 0 - 59
  int h = hour();    // Values from 0 - 23
  String ds = str(d);
  String ms = str(m);
  String ys = str(y);
  String ss = str(s);
  String mins = str(min);
  String hs = str(h);
  fecha = ys+ms+ds+hs+mins+ss;
  //println(fecha);
}

void kinect3D(){
  // =========Kinect 3D

  // Get the raw depth as array of integers
  int[] depth = kinect.getRawDepth();

  // We're just going to calculate and draw every 4th pixel (equivalent of 160x120)
  int skip = 4;

  // Translate and rotate
  translate(800, 150, 0); //x = posición inicial, más la mitad, y a cálculo
 // rotateY(a);

  for (int x = 0; x < kinect.width; x += skip) {
    for (int y = 0; y < kinect.height; y += skip) {
      int offset = x + y*kinect.width;

      // Convert kinect data to world xyz coordinate
      int rawDepth = depth[offset];
      PVector v = depthToWorld(x, y, rawDepth);

      stroke(255);
      pushMatrix();
      // Scale up by 200
      float factor = 200;
      translate(v.x*factor, v.y*factor, factor-v.z*factor);
      // Draw a point
      point(0, 0);
      popMatrix();
    }
  }

  // Rotate
  // a += 0.00015f;
 
}




void texto() {
  velocidad = velocidad-1;
  manifesto(velocidad);
}


void manifesto(int posY){
  String[] lines = loadStrings("text/text1.txt");
 // println("there are " + lines.length + " lines");
  for (int ia = 0 ; ia < lines.length; ia++) {
    posRot= posY+(40+ia*20);
    // text(lines[ia], posTextX, posRot);
     if (posRot<400){
     //text(".", posTextX, posRot);
     } else {
     text(lines[ia], posTextX, posRot);
     }
    if (ia == lines.length){
      ia=0;
      posRot = posY+(40+ia*20);
    }     

   }

}

import org.openkinect.freenect.*; //openkinect
import org.openkinect.processing.*; //openkinect
import processing.video.*; //video cámara
import com.hamoid.*;  //export

// Objetos
PWindow win; //Objeto de ventana
Kinect kinect; //Kinect
Capture video; //WebCam1
Capture video1; //WebCam2
VideoExport videoExport; //Record
// Declaración de variables
boolean recording = false;
int parar = 0;
String fecha; //fecha
float a = 0; // Angle for rotation
float[] depthLookUp = new float[2048]; // We'll use a lookup table so that we don't have to repeat the math over and over
PFont f; //fuente de texto
int posTextY; //Posición de texto en Y
int posTextX; //Posición de texto en X
int velocidad; //Velocidad de texto
int posRot;

void setup() {
  
  win = new PWindow();
  // Texto
  f = createFont("Arial Narrow", 20);   // Create the font
  textFont(f);
  posTextY = 800;  //Posición texto respecto a y
  posTextX = 420;
  String[] lines = loadStrings("text.txt");


  // Video Export
  videoExport = new VideoExport(this);
  videoExport.setDebugging(false);
  
  
// Cámaras Web 
  String[] cameras = Capture.list();
  
  if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
    } else {
    println("Available cameras:");
    for (int i = 0; i < cameras.length; i++) {
      println(i+"--"+cameras[i]);
    }

  video = new Capture(this, cameras[1]);
  video1 = new Capture(this, cameras[26]);
  video.start();
  video1.start();
    }
  
  // ========Kinect 3D==================
  
  kinect = new Kinect(this);
  kinect.initDepth();

  // Lookup table for all possible depth values (0 - 2047)
  for (int i = 0; i < depthLookUp.length; i++) {
    depthLookUp[i] = rawDepthToMeters(i);
  }
    
} //Fin setup

void draw() {
  background(0);
  texto();
 
  
  //========= WebCam
  if (video.available()) {
    video.read();
  }
  if (video1.available()) {
    video1.read();
  }

  // Configuración de los filtros de video
  video.filter(THRESHOLD);
  video1.filter(GRAY);
  // Posición y configuración del video como imagen
  image(video, 0, 0, 400, 300);
  image(video1, 0, 300, 400, 300);
  
  kinect3D(); //Llamada a función de kinect
  
  // Video Export
    if (recording) {
      videoExport.saveFrame();
    }  
} // Fin de Draw

// These functions come from: http://graphics.stanford.edu/~mdfisher/Kinect.html
float rawDepthToMeters(int depthValue) {
  if (depthValue < 2047) {
    return (float)(1.0 / ((double)(depthValue) * -0.0030711016 + 3.3309495161));
  }
  return 0.0f;
}

PVector depthToWorld(int x, int y, int depthValue) {

  final double fx_d = 1.0 / 5.9421434211923247e+02;
  final double fy_d = 1.0 / 5.9104053696870778e+02;
  final double cx_d = 3.3930780975300314e+02;
  final double cy_d = 2.4273913761751615e+02;

  PVector result = new PVector();
  double depth =  depthLookUp[depthValue];//rawDepthToMeters(depthValue);
  result.x = (float)((x - cx_d) * depth * fx_d);
  result.y = (float)((y - cy_d) * depth * fy_d);
  result.z = (float)(depth);
  return result;
}  

class PWindow extends PApplet {
  PWindow() {
    super();
    PApplet.runSketch(new String[] {this.getClass().getSimpleName()}, this);
  }

  void settings() {
    size(150, 800);
  }

  void setup() {
    background(0);
  }

  void draw() {
    ellipse(random(width), random(height), random(50), random(50));
  }

  void mousePressed() {
    println("mousePressed in thirty window");
  }
}

public void settings(){
  size(1200, 600, P3D); // Rendering in P3D
}

void keyPressed() {
  if (key == 'q') {
    fecha();
    recording = true;
    videoExport.setMovieFileName("data/"+ fecha + ".mp4");
    videoExport.startMovie();
    println("Start movie.");
  } else if (key == 'w') {
    recording = false;
    videoExport.endMovie();

  } else if (key == ESC){
    parar = 0;
  }
}

void fecha() {
  background(204);
  int d = day();    // Values from 1 - 31
  int m = month();  // Values from 1 - 12
  int y = year(); 
  int s = second();  // Values from 0 - 59
  int min = minute();  // Values from 0 - 59
  int h = hour();    // Values from 0 - 23
  String ds = str(d);
  String ms = str(m);
  String ys = str(y);
  String ss = str(s);
  String mins = str(min);
  String hs = str(h);
  fecha = ys+ms+ds+hs+mins+ss;
  //println(fecha);
}

void kinect3D(){
  // =========Kinect 3D

  // Get the raw depth as array of integers
  int[] depth = kinect.getRawDepth();

  // We're just going to calculate and draw every 4th pixel (equivalent of 160x120)
  int skip = 4;

  // Translate and rotate
  translate(800, 150, 0); //x = posición inicial, más la mitad, y a cálculo
 // rotateY(a);

  for (int x = 0; x < kinect.width; x += skip) {
    for (int y = 0; y < kinect.height; y += skip) {
      int offset = x + y*kinect.width;

      // Convert kinect data to world xyz coordinate
      int rawDepth = depth[offset];
      PVector v = depthToWorld(x, y, rawDepth);

      stroke(255);
      pushMatrix();
      // Scale up by 200
      float factor = 200;
      translate(v.x*factor, v.y*factor, factor-v.z*factor);
      // Draw a point
      point(0, 0);
      popMatrix();
    }
  }

  // Rotate
  // a += 0.00015f;
 
}




void texto() {
  velocidad = velocidad-1;
  manifesto(velocidad);
}


void manifesto(int posY){
  String[] lines = loadStrings("text/text1.txt");
 // println("there are " + lines.length + " lines");
  for (int ia = 0 ; ia < lines.length; ia++) {
    posRot= posY+(40+ia*20);
    // text(lines[ia], posTextX, posRot);
     if (posRot<400){
     //text(".", posTextX, posRot);
     } else {
     text(lines[ia], posTextX, posRot);
     }
    if (ia == lines.length){
      ia=0;
      posRot = posY+(40+ia*20);
    }     

   }

}

import org.openkinect.freenect.*; //openkinect
import org.openkinect.processing.*; //openkinect
import processing.video.*; //video cámara
import com.hamoid.*;  //export

// Objetos
PWindow win; //Objeto de ventana
Kinect kinect; //Kinect
Capture video; //WebCam1
Capture video1; //WebCam2
VideoExport videoExport; //Record
// Declaración de variables
boolean recording = false;
int parar = 0;
String fecha; //fecha
float a = 0; // Angle for rotation
float[] depthLookUp = new float[2048]; // We'll use a lookup table so that we don't have to repeat the math over and over
PFont f; //fuente de texto
int posTextY; //Posición de texto en Y
int posTextX; //Posición de texto en X
int velocidad; //Velocidad de texto
int posRot;

void setup() {
  
  win = new PWindow();
  // Texto
  f = createFont("Arial Narrow", 20);   // Create the font
  textFont(f);
  posTextY = 800;  //Posición texto respecto a y
  posTextX = 420;
  String[] lines = loadStrings("text.txt");


  // Video Export
  videoExport = new VideoExport(this);
  videoExport.setDebugging(false);
  
  
// Cámaras Web 
  String[] cameras = Capture.list();
  
  if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
    } else {
    println("Available cameras:");
    for (int i = 0; i < cameras.length; i++) {
      println(i+"--"+cameras[i]);
    }

  video = new Capture(this, cameras[1]);
  video1 = new Capture(this, cameras[26]);
  video.start();
  video1.start();
    }
  
  // ========Kinect 3D==================
  
  kinect = new Kinect(this);
  kinect.initDepth();

  // Lookup table for all possible depth values (0 - 2047)
  for (int i = 0; i < depthLookUp.length; i++) {
    depthLookUp[i] = rawDepthToMeters(i);
  }
    
} //Fin setup

void draw() {
  background(0);
  texto();
 
  
  //========= WebCam
  if (video.available()) {
    video.read();
  }
  if (video1.available()) {
    video1.read();
  }

  // Configuración de los filtros de video
  video.filter(THRESHOLD);
  video1.filter(GRAY);
  // Posición y configuración del video como imagen
  image(video, 0, 0, 400, 300);
  image(video1, 0, 300, 400, 300);
  
  kinect3D(); //Llamada a función de kinect
  
  // Video Export
    if (recording) {
      videoExport.saveFrame();
    }  
} // Fin de Draw

// These functions come from: http://graphics.stanford.edu/~mdfisher/Kinect.html
float rawDepthToMeters(int depthValue) {
  if (depthValue < 2047) {
    return (float)(1.0 / ((double)(depthValue) * -0.0030711016 + 3.3309495161));
  }
  return 0.0f;
}

PVector depthToWorld(int x, int y, int depthValue) {

  final double fx_d = 1.0 / 5.9421434211923247e+02;
  final double fy_d = 1.0 / 5.9104053696870778e+02;
  final double cx_d = 3.3930780975300314e+02;
  final double cy_d = 2.4273913761751615e+02;

  PVector result = new PVector();
  double depth =  depthLookUp[depthValue];//rawDepthToMeters(depthValue);
  result.x = (float)((x - cx_d) * depth * fx_d);
  result.y = (float)((y - cy_d) * depth * fy_d);
  result.z = (float)(depth);
  return result;
}  

class PWindow extends PApplet {
  PWindow() {
    super();
    PApplet.runSketch(new String[] {this.getClass().getSimpleName()}, this);
  }

  void settings() {
    size(150, 800);
  }

  void setup() {
    background(0);
  }

  void draw() {
    ellipse(random(width), random(height), random(50), random(50));
  }

  void mousePressed() {
    println("mousePressed in thirty window");
  }
}

public void settings(){
  size(1200, 600, P3D); // Rendering in P3D
}

void keyPressed() {
  if (key == 'q') {
    fecha();
    recording = true;
    videoExport.setMovieFileName("data/"+ fecha + ".mp4");
    videoExport.startMovie();
    println("Start movie.");
  } else if (key == 'w') {
    recording = false;
    videoExport.endMovie();

  } else if (key == ESC){
    parar = 0;
  }
}

void fecha() {
  background(204);
  int d = day();    // Values from 1 - 31
  int m = month();  // Values from 1 - 12
  int y = year(); 
  int s = second();  // Values from 0 - 59
  int min = minute();  // Values from 0 - 59
  int h = hour();    // Values from 0 - 23
  String ds = str(d);
  String ms = str(m);
  String ys = str(y);
  String ss = str(s);
  String mins = str(min);
  String hs = str(h);
  fecha = ys+ms+ds+hs+mins+ss;
  //println(fecha);
}

void kinect3D(){
  // =========Kinect 3D

  // Get the raw depth as array of integers
  int[] depth = kinect.getRawDepth();

  // We're just going to calculate and draw every 4th pixel (equivalent of 160x120)
  int skip = 4;

  // Translate and rotate
  translate(800, 150, 0); //x = posición inicial, más la mitad, y a cálculo
 // rotateY(a);

  for (int x = 0; x < kinect.width; x += skip) {
    for (int y = 0; y < kinect.height; y += skip) {
      int offset = x + y*kinect.width;

      // Convert kinect data to world xyz coordinate
      int rawDepth = depth[offset];
      PVector v = depthToWorld(x, y, rawDepth);

      stroke(255);
      pushMatrix();
      // Scale up by 200
      float factor = 200;
      translate(v.x*factor, v.y*factor, factor-v.z*factor);
      // Draw a point
      point(0, 0);
      popMatrix();
    }
  }

  // Rotate
  // a += 0.00015f;
 
}




void texto() {
  velocidad = velocidad-1;
  manifesto(velocidad);
}


void manifesto(int posY){
  String[] lines = loadStrings("text/text1.txt");
 // println("there are " + lines.length + " lines");
  for (int ia = 0 ; ia < lines.length; ia++) {
    posRot= posY+(40+ia*20);
    // text(lines[ia], posTextX, posRot);
     if (posRot<400){
     //text(".", posTextX, posRot);
     } else {
     text(lines[ia], posTextX, posRot);
     }
    if (ia == lines.length){
      ia=0;
      posRot = posY+(40+ia*20);
    }     

   }

}

import org.openkinect.freenect.*; //openkinect
import org.openkinect.processing.*; //openkinect
import processing.video.*; //video cámara
import com.hamoid.*;  //export

// Objetos
PWindow win; //Objeto de ventana
Kinect kinect; //Kinect
Capture video; //WebCam1
Capture video1; //WebCam2
VideoExport videoExport; //Record
// Declaración de variables
boolean recording = false;
int parar = 0;
String fecha; //fecha
float a = 0; // Angle for rotation
float[] depthLookUp = new float[2048]; // We'll use a lookup table so that we don't have to repeat the math over and over
PFont f; //fuente de texto
int posTextY; //Posición de texto en Y
int posTextX; //Posición de texto en X
int velocidad; //Velocidad de texto
int posRot;

void setup() {
  
  win = new PWindow();
  // Texto
  f = createFont("Arial Narrow", 20);   // Create the font
  textFont(f);
  posTextY = 800;  //Posición texto respecto a y
  posTextX = 420;
  String[] lines = loadStrings("text.txt");


  // Video Export
  videoExport = new VideoExport(this);
  videoExport.setDebugging(false);
  
  
// Cámaras Web 
  String[] cameras = Capture.list();
  
  if (cameras.length == 0) {
    println("There are no cameras available for capture.");
    exit();
    } else {
    println("Available cameras:");
    for (int i = 0; i < cameras.length; i++) {
      println(i+"--"+cameras[i]);
    }

  video = new Capture(this, cameras[1]);
  video1 = new Capture(this, cameras[26]);
  video.start();
  video1.start();
    }
  
  // ========Kinect 3D==================
  
  kinect = new Kinect(this);
  kinect.initDepth();

  // Lookup table for all possible depth values (0 - 2047)
  for (int i = 0; i < depthLookUp.length; i++) {
    depthLookUp[i] = rawDepthToMeters(i);
  }
    
} //Fin setup

void draw() {
  background(0);
  texto();
 
  
  //========= WebCam
  if (video.available()) {
    video.read();
  }
  if (video1.available()) {
    video1.read();
  }

  // Configuración de los filtros de video
  video.filter(THRESHOLD);
  video1.filter(GRAY);
  // Posición y configuración del video como imagen
  image(video, 0, 0, 400, 300);
  image(video1, 0, 300, 400, 300);
  
  kinect3D(); //Llamada a función de kinect
  
  // Video Export
    if (recording) {
      videoExport.saveFrame();
    }  
} // Fin de Draw

// These functions come from: http://graphics.stanford.edu/~mdfisher/Kinect.html
float rawDepthToMeters(int depthValue) {
  if (depthValue < 2047) {
    return (float)(1.0 / ((double)(depthValue) * -0.0030711016 + 3.3309495161));
  }
  return 0.0f;
}

PVector depthToWorld(int x, int y, int depthValue) {

  final double fx_d = 1.0 / 5.9421434211923247e+02;
  final double fy_d = 1.0 / 5.9104053696870778e+02;
  final double cx_d = 3.3930780975300314e+02;
  final double cy_d = 2.4273913761751615e+02;

  PVector result = new PVector();
  double depth =  depthLookUp[depthValue];//rawDepthToMeters(depthValue);
  result.x = (float)((x - cx_d) * depth * fx_d);
  result.y = (float)((y - cy_d) * depth * fy_d);
  result.z = (float)(depth);
  return result;
}  

class PWindow extends PApplet {
  PWindow() {
    super();
    PApplet.runSketch(new String[] {this.getClass().getSimpleName()}, this);
  }

  void settings() {
    size(150, 800);
  }

  void setup() {
    background(0);
  }

  void draw() {
    ellipse(random(width), random(height), random(50), random(50));
  }

  void mousePressed() {
    println("mousePressed in thirty window");
  }
}

public void settings(){
  size(1200, 600, P3D); // Rendering in P3D
}

void keyPressed() {
  if (key == 'q') {
    fecha();
    recording = true;
    videoExport.setMovieFileName("data/"+ fecha + ".mp4");
    videoExport.startMovie();
    println("Start movie.");
  } else if (key == 'w') {
    recording = false;
    videoExport.endMovie();

  } else if (key == ESC){
    parar = 0;
  }
}

void fecha() {
  background(204);
  int d = day();    // Values from 1 - 31
  int m = month();  // Values from 1 - 12
  int y = year(); 
  int s = second();  // Values from 0 - 59
  int min = minute();  // Values from 0 - 59
  int h = hour();    // Values from 0 - 23
  String ds = str(d);
  String ms = str(m);
  String ys = str(y);
  String ss = str(s);
  String mins = str(min);
  String hs = str(h);
  fecha = ys+ms+ds+hs+mins+ss;
  //println(fecha);
}

void kinect3D(){
  // =========Kinect 3D

  // Get the raw depth as array of integers
  int[] depth = kinect.getRawDepth();

  // We're just going to calculate and draw every 4th pixel (equivalent of 160x120)
  int skip = 4;

  // Translate and rotate
  translate(800, 150, 0); //x = posición inicial, más la mitad, y a cálculo
 // rotateY(a);

  for (int x = 0; x < kinect.width; x += skip) {
    for (int y = 0; y < kinect.height; y += skip) {
      int offset = x + y*kinect.width;

      // Convert kinect data to world xyz coordinate
      int rawDepth = depth[offset];
      PVector v = depthToWorld(x, y, rawDepth);

      stroke(255);
      pushMatrix();
      // Scale up by 200
      float factor = 200;
      translate(v.x*factor, v.y*factor, factor-v.z*factor);
      // Draw a point
      point(0, 0);
      popMatrix();
    }
  }

  // Rotate
  // a += 0.00015f;
 
}




void texto() {
  velocidad = velocidad-1;
  manifesto(velocidad);
}


void manifesto(int posY){
  String[] lines = loadStrings("text/text1.txt");
 // println("there are " + lines.length + " lines");
  for (int ia = 0 ; ia < lines.length; ia++) {
    posRot= posY+(40+ia*20);
    // text(lines[ia], posTextX, posRot);
     if (posRot<400){
     //text(".", posTextX, posRot);
     } else {
     text(lines[ia], posTextX, posRot);
     }
    if (ia == lines.length){
      ia=0;
      posRot = posY+(40+ia*20);
    }     

   }

}

